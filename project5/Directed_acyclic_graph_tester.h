/*************************************************
 * Directed_acyclic_graph_tester
 * A class for testing binary min heaps.
 *
 * Author:  Douglas Wilhelm Harder
 * Copyright (c) 2006-8 by Douglas Wilhelm Harder.  All rights reserved.
 *
 * DO NOT EDIT THIS FILE
 *************************************************/

#ifndef DIRECTED_ACYCLIC_GRAPH_TESTER_H
#define DIRECTED_ACYCLIC_GRAPH_TESTER_H

#define PARAMETERIZED

#include "Exception.h"
#include "Tester.h"
#include "Directed_acyclic_graph.h"

#include <iostream>

class Directed_acyclic_graph_tester:public Tester< Directed_acyclic_graph > {
	using Tester< Directed_acyclic_graph >::object;
	using Tester< Directed_acyclic_graph >::command;

	public:
		Directed_acyclic_graph_tester( Directed_acyclic_graph *obj = 0 ):Tester<Directed_acyclic_graph>( obj ) {
			// empty
		}

		void process();
};

/****************************************************
 * void process()
 *
 * Process the current command.  For binary min heaps, these include:
 *
 *      new                 new Directed_acyclic_graph()
 *      new: n              new Directed_acyclic_graph( n )
 *	in i n              in_degree( i ) == n
 *	out i n             out_degree( i ) == n
 *	edges n             edge_count() == n
 *	adjacent i j b      adjacent( i, j ) == b
 *	connected i j b     connected( i, j ) == b
 *	sort                topological_sort()
 *
 *	set i p b           set_priority( i, p ) == b
 *	insert i j b        insert_edge( i, j ) == b
 *	clear               clear_edges()
 *	reset               reset_priorities()
 *
 *  Others
 *   cout            cout << dag     print the dag (for testing only)
 *   assign          operator =      assign this dag to a new list
 *   summary                         prints the amount of memory allocated
 *                                   minus the memory deallocated
 *   details                         prints a detailed description of which
 *                                   memory was allocated with details
 *   !!                              use the previous command, e.g.  5 push_front 3
 *                                                                   6 !! 7         // same as push_front 7
 *   !n                              use the command used in line n  7 front 7
 *                                                                   8 !7 9         // same as push_front 9
 *
 ****************************************************/

void Directed_acyclic_graph_tester::process() {
	if ( command == "new" ) {
		object = new Directed_acyclic_graph();
		std::cout << "Okay" << std::endl;
	} else if ( command == "new:" ) {
		int n;
		std::cin >> n;
		object = new Directed_acyclic_graph( n );
		std::cout << "Okay" << std::endl;
	} else if ( command == "in" ) {
		int i;
		std::cin >> i;

		int expected_in_degree;
		std::cin >> expected_in_degree;

		int actual_in_degree = object->in_degree( i );

		if ( actual_in_degree == expected_in_degree ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in in_degree( " << i << " ): expecting the value '" << expected_in_degree << "' but got '" << actual_in_degree << "'" << std::endl;
		}
	} else if ( command == "out" ) {
		int i;
		std::cin >> i;

		int expected_out_degree;
		std::cin >> expected_out_degree;

		int actual_out_degree = object->out_degree( i );

		if ( actual_out_degree == expected_out_degree ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in out_degree( " << i << " ): expecting the value '" << expected_out_degree << "' but got '" << actual_out_degree << "'" << std::endl;
		}
	} else if ( command == "edges" ) {
		int expected_edge_count;
		std::cin >> expected_edge_count;

		int actual_edge_count = object->edge_count();

		if ( actual_edge_count == expected_edge_count ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in edge_count(): expecting the value '" << expected_edge_count << "' but got '" << actual_edge_count << "'" << std::endl;
		}
	} else if ( command == "adjacent" ) {
		int i, j;
		std::cin >> i;
		std::cin >> j;

		bool expected_adjacent;
		std::cin >> expected_adjacent;

		int actual_adjacent = object->adjacent( i, j );

		if ( actual_adjacent == expected_adjacent ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in adjacent( " << i << "," << j << " ): expecting the value '" << expected_adjacent << "' but got '" << actual_adjacent << "'" << std::endl;
		}
	} else if ( command == "connected" ) {
		int i, j;
		std::cin >> i;
		std::cin >> j;

		bool expected_connected;
		std::cin >> expected_connected;

		int actual_connected = object->connected( i, j );

		if ( actual_connected == expected_connected ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in connected( " << i << "," << j << " ): expecting the value '" << expected_connected << "' but got '" << actual_connected << "'" << std::endl;
		}
	} else if ( command == "sort" ) {
		object->topological_sort();
		std::cout << std::endl;
	} else if ( command == "set" ) {
		int i;
		std::cin >> i;

		double p;
		std::cin >> p;

		bool expected_set_priority;
		std::cin >> expected_set_priority;

		bool actual_set_priority = object->set_priority( i, p );

		if ( actual_set_priority == expected_set_priority ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in set_priority( " << i << "," << p << " ): expecting the value '" << expected_set_priority << "' but got '" << actual_set_priority << "'" << std::endl;
		}
	} else if ( command == "insert" ) {
		int i, j;
		std::cin >> i;
		std::cin >> j;

		bool expected_insert_edge;
		std::cin >> expected_insert_edge;

		int actual_insert_edge = object->insert_edge( i, j );

		if ( actual_insert_edge == expected_insert_edge ) {
			std::cout << "Okay" << std::endl;
		} else {
			std::cout << "Failure in insert_edge( " << i << "," << j << " ): expecting the value '" << expected_insert_edge << "' but got '" << actual_insert_edge << "'" << std::endl;
		}
	} else if ( command == "clear" ) {
		object->clear_edges();
		std::cout << "Okay" << std::endl;
	} else if ( command == "reset" ) {
		object->reset_priorities();
		std::cout << "Okay" << std::endl;
	} else if ( command == "assign" ) {
		Directed_acyclic_graph *new_object = new Directed_acyclic_graph();

		*new_object = *object;

		std::cout << "Okay" << std::endl;

		Directed_acyclic_graph_tester tester( new_object );

		tester.run();
	} else if ( command == "cout" ) {
		std::cout << *object << std::endl;
	} else {
		std::cout << command << ": Command not found." << std::endl;
	}
}

#endif